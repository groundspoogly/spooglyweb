<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Xen Console</title>
<style>
body {
	background-color: #000;
	color: #fff;
	font-family: sans-serif;
}
svg, table, th, td {
	border: 1px solid #777;
}
.doubleBorder {
	border-left: double #777 3px;
}
table, td {
	border-collapse: collapse;
	padding: 6px;
}
td {
	border-collapse: collapse;
	padding: 6px;
}
.tableHeader {
	background-color: #a9c;
	color: #000;
	font-weight: bold;
}
.columnColor {
	background-color: #333;
}
.equalTable tr {
	height: 20px;
}
.equalTable td {
	width: 20px;
}
.genCircleText {
	font-family: sans-serif;
	stroke: #000;
	stroke-width: 2px;
	paint-order: stroke; /* stroke before fill */
	text-anchor: middle; /* center horizontally */
	dominant-baseline: middle; /* center vertically */
}
</style>
<script type="text/javascript" src="noteNames.js"></script>
<script type="text/javascript" src="helperFunctions.js"></script>
<script type="text/javascript" src="monzoOperations.js"></script>
<script>
/* in these documents:
- "r" is a ratio where the denominator is the first element in the array: [d, n, (n2), (n3)...]
- "q" is the floating point version of the ratio between two numbers
- "n" and "d" are the numerator and denominator
- "m" is a compact monzo
- "g" is the number of generators
- "a," "b," and "c" are just numbers (usually integers) in various functions

Functions:
void reaperNoteNames(x)
	reaperNoteNames(41);
void drawApproxChart(pitchUnit, targetPitch, minPitch, maxPitch, pitchLabelStep, minEdo, maxEdo, edoLabelStep)
	drawApproxChart('c', rToC([2,3]), 685, 720, 5, 5, 55, 5);
*/

function reaperNoteNames(labelsArray) {
	// labelsArray can use the autoNoteNames() function or just take an index from noteNames[]
	
	const addEdo = false;
	
	if (arguments.length != 1) throw 'Internal Error: Wrong number of arguments.';
	const modNegativeBuffer = labelsArray.length * 128;
	let html = '<pre>';
	for (let i = 0; i <= 127; i++) {
		let position = (i - 69 + modNegativeBuffer) % labelsArray.length;
		let note = labelsArray[position] + (addEdo & position == 0 ? ' (' + labelsArray.length + ')' : ''); // 57 for kontakt if A2 is the root instead of A3
		html += '      -1 ' + i + ' ' + (note.includes(' ') ? '\"' : '') + (note == '' ? '\" \"' : note) + (note.includes(' ') ? '\"' : '') + ' 0 ' + i + '\n';
	}
	document.body.innerHTML = html + '</pre>';
	return 'Printed Reaper note names for provided array.';
}

function autoNoteNames(pitchUnit, x, y, unisonLabel, decimalPlaces) {
	// pitchUnit
	// x             Tuning: XedY
	// y             Tuning: XedY
	// unisonLabel   The label for the first note in the array (you could use 0 for any tuning, but I like to use 1200 for edos)
	// decimalPlaces
	
	if (arguments.length != 5) throw 'Internal Error: Wrong number of arguments.';
	const yUnits = octavesToPitchUnits(pitchUnit, Math.log2(y));
	let labelsTemp = [unisonLabel];
	for (let i = 1; i < x; i++) {
		let pitch = yUnits*i/x;
		labelsTemp.push(Number.isInteger(pitch) ? pitch : (pitch).toFixed(decimalPlaces));
	}
	return labelsTemp;
}

function drawETMappingTable(pitchUnit, x, y, primes, warts) { // TODO
	// pitchUnit
	// x         Tuning: XedY
	// y         Tuning: XedY
	// primes    Array of primes to map
	// warts     Array of warts starting with the first prime, with 0 being the patent val approximation
	
	if (arguments.length != 5) throw 'Internal Error: Wrong number of arguments.';
	
	let mappings = [];
	for (let i = 0; i < primes.length; i++) {
		mappings.push([primes[i]]); // create a row for the given prime
		for (let j = 1; j <= x; j++) { // for every step of the ET except 0, because putting a wart on "prime" 1 wouldn't make sense anyway
			mappings[i].push(j);
		}
	}
	console.log(mappings);
	
	document.body.innerHTML = '<div id="info" /><table id="table" />';
	const inof = document.getElementById('info');
	const table = document.getElementById('table');
	
	table.innerHTML = '<tr><th>Step</th><th>Cents</th>';
	
	table.innerHTML += '</tr>';
}

function createLatticeButtons(pitchUnit, dimensions, edges) {
	// dimensions = [period, generator, offset, ... TODO extra dimensions] (all eigenmonzos)
	// edges = [min generators, max generators, min offsets, max offsets, ...] (all eigenmonzos)
	// createLatticeButtons('c', [cents(2), cents(3), cents(5)], [-12, 12, -5, 5]);
	
	let html = '<table><tr><td />';
	for (let x = edges[2]; x <= edges[3]; x++) html += '<td>' + x + '</td>';
	html += '</tr>';
	for (let y = edges[0]; y <= edges[1]; y++) {
		html += '<tr><td>' + y + '</td>';
		for (let x = edges[2]; x <= edges[3]; x++) {
			html += '<td><button>' + x*y + '</button></td>';
		}
		html += '</tr>';
	}
	document.body.innerHTML = html + '</table>'; // TODO this way of populating a table is better, so use it more
		// TODO all this
		//cents(eigenmonzo(
}

function drawScaleComparison(stepsArr, textArr) { // TODO: this is a mess
	// drawScaleComparison([
	// [2, 1, 2, 2, 1, 2, 1],
	// [2, 1, 2, 2, 1, 2, 2],
	// [2, 1, 2, 2, 1, 2, 2, 1]], [
	// [text, textX, textY, textSize, textRotation],
	// [text, textX, textY, textSize, textRotation]]);
	
	if (arguments.length != 1) throw 'Internal Error: Wrong number of arguments.';
	
	const width = window.innerWidth - 40;
	const height = window.innerHeight - 40;
	const xMargin = 20;
	const yMargin = 20;
	const scaleWidth = 100;
	const scaleHeight = 400;
	const lineWidth = 2;
	const outlineWidth = 1;
	document.body.innerHTML = '<svg id="chart" style="width: ' + width + 'px; height: ' + height + 'px;">Your browser does not support inline SVG.</svg>';
	
	document.getElementById('chart').innerHTML = '<line stroke="#fff" stroke-linecap="round" stroke-width="' + (lineWidth + outlineWidth) + '" x1="0" x2="0" y1="0" y2="-0.4"/>';
	
	for (let i = 0; i < textArr.length; i++) {	
		document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + textArr[i][1] + '" y="' + textArr[i][2] + '"transform="' + textArr[i][3] + '" font-size="' + textArr[i][3] + 'px" fill="#daf" font-weight="bold">' + textArr[i][0] + '</text>';
	}
}

function drawGeneratorCircle(pitchUnit, n, gen, nPerTurn, transitionNotes, r1, r2, angleOffset, reverseDirection, angleMultiplier) {
	// pitchUnit
	// n                Number of equal divisions
	// gen              Number of steps in the generator
	// nPerTurn         Number of generators per turn
	// transitionNotes  Number of extra notes at either end of the spiral
	// r1               Inner radius
	// r2               Outer radius
	// angleOffset      Starting angle
	// reverseDirection Boolean to reverse rotation direction
	// angleMultiplier  Number to multiply all angles by. Set to 1 for no alteration.
	// drawGeneratorCircle('c', 27, 16, 5, 1, 100, 420, -1/4, true, 26/27)
	
	if (arguments.length != 10) throw 'Internal Error: Wrong number of arguments.';
	
	const width = window.innerWidth - 40;
	const height = window.innerHeight - 40;
	const Xcenter = width / 2;
	const Ycenter = height / 2 + 20; // vertical offset
	const textOffset = 12;
	const textSize = 24;
	const offset = Math.ceil(n/2);
	
	document.body.innerHTML = '<svg id="chart" style="width: ' + width + 'px; height: ' + height + 'px;">Your browser does not support inline SVG.</svg>';
	
	document.getElementById('chart').innerHTML = '<polyline id="spiral" fill="none" stroke="#777" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />';
	let points = '';
	for (let i = -offset - transitionNotes; i < n - offset + transitionNotes; i++) {
		let rChange = (r2 - r1) * (i + offset + transitionNotes) / (n + transitionNotes);
		let x = Xcenter + (reverseDirection ? r2 - rChange : r1 + rChange) * Math.cos((i/nPerTurn + angleOffset) * 2 * Math.PI * angleMultiplier);
		let y = Ycenter + (reverseDirection ? r2 - rChange : r1 + rChange) * Math.sin((i/nPerTurn + angleOffset) * 2 * Math.PI * angleMultiplier);
		let pitch = (i * gen).mod(n);
		if (i + offset < 0 || i + offset >= n) {
			document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + x + '" y="' + y + '" font-size="' + textSize + 'px" fill="#ddd">(' + noteNames[n][(pitch + n - gen) % n] + ')</text>';
		} else {
			document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + x + '" y="' + (y - textOffset) + '" font-size="' + textSize + 'px" fill="#daf" font-weight="bold">' + noteNames[n][(pitch + n - gen) % n] + '</text>';
			document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + x + '" y="' + (y + textOffset) + '" font-size="' + textSize + 'px" fill="#fff">' + pitchUnitText(pitchUnit, Math.round(octavesToPitchUnits(pitchUnit, pitch/n))) + '</text>';
		}
		points += x + ',' + y + ' ';
	}
	
	document.getElementById('spiral').setAttribute('points', points);
	document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + Xcenter + '" y="' + Ycenter + '" font-size="72px" fill="#daf">' + n + '</text>';
}

function drawContortedGeneratorCircle(pitchUnit, n, gen, nPerCircle, r1, r2, angleOffset) {
	if (arguments.length != 7) throw 'Internal Error: Wrong number of arguments.';
	
	const width = window.innerWidth - 40;
	const height = window.innerHeight - 40;
	const Xcenter = width / 2;
	const Ycenter = height / 2 + 20; // vertical offset
	const textOffset = 12;
	const textSize = 24;
	const offset = Math.ceil(nPerCircle/2) - 1;
	const circleCount = n / nPerCircle;
	
	document.body.innerHTML = '<svg id="chart" style="width: ' + width + 'px; height: ' + height + 'px;">Your browser does not support inline SVG.</svg>';
	
	for (let j = -offset; j < circleCount - offset; j++) {
		document.getElementById('chart').innerHTML += '<polygon id="spiral' + j + '" fill="none" stroke="#777" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />';
		let points = '';
		for (let i = -offset; i < nPerCircle - offset; i++) {
			let r = r1 + (r2 - r1) * (j + offset) / circleCount;
			let x = Xcenter + r * Math.cos((i/nPerCircle + angleOffset) * 2 * Math.PI);
			let y = Ycenter + r * Math.sin((i/nPerCircle + angleOffset) * 2 * Math.PI);
			let pitch = (i * gen + j).mod(n);
			document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + x + '" y="' + (y - textOffset) + '" font-size="' + textSize + 'px" fill="#daf" font-weight="bold">' + noteNames[n][(pitch + n - gen) % n] + '</text>';
			document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + x + '" y="' + (y + textOffset) + '" font-size="' + textSize + 'px" fill="#fff">' + pitchUnitText(pitchUnit, Math.round(octavesToPitchUnits(pitchUnit, pitch/n))) + '</text>';
			points += x + ',' + y + ' ';
		}
		
		document.getElementById('spiral' + j).setAttribute('points', points);
	}
	document.getElementById('chart').innerHTML += '<text class="genCircleText" x="' + Xcenter + '" y="' + Ycenter + '" font-size="72px" fill="#daf">' + n + '</text>';
}

function drawApproxChart(pitchUnit, targetPitch, minPitch, maxPitch, pitchLabelStep, minEdo, maxEdo, edoLabelStep) {
	// drawApproxChart('c', 700, 690, 710, 1, 5, 72, 5)
	
	if (arguments.length != 8) throw 'Internal Error: Wrong number of arguments.';
	
	const width = window.innerWidth - 40;
	const height = window.innerHeight - 40;
	const marginX = 50;
	const marginY = 40;
	const lineRadius = 12;
	const accentHue = 250; // the only transparency is used here
	
	const pitchStepX = (width - 2*marginX) / (maxPitch - minPitch); // pixel difference between each octave on the x-axis
	const edoStepY = (height - 2*marginY) / (maxEdo - minEdo); // pixel difference between each edo on the y-axis
	
	document.body.innerHTML = '<svg id="chart" style="width: ' + width + 'px; height: ' + height + 'px;">Your browser does not support inline SVG.</svg>'; // set width and height with JS so the diagram doesn't change when the window is resized until it's generated again
	
	// add pitch unit grid lines
	for (let u = Math.ceil(minPitch / pitchLabelStep) * pitchLabelStep; u <= maxPitch; u += pitchLabelStep) { // TODO: decimal pitchLabelStep can cause the first or last line not to display when they're supposed to be equal
		let x = marginX + (u - minPitch)*pitchStepX;
		document.getElementById('chart').innerHTML +=
		'<line x1="' + x + '" y1="' + (marginY*2/3) + '" x2="' + x + '" y2="' + (height - marginY*2/3) + '" style="stroke: dimGray; stroke-width: 1;" />'
		+ '<text x="' + (x - 10) + '" y="' + (marginY*2/3 - 8) + '" font-size="12px" font-family="sans-serif" fill="lightGray">' + pitchUnitText(pitchUnit, u) + '</text>';
	}
	// add edo grid lines
	for (let edo = minEdo; edo <= maxEdo; edo += edoLabelStep) { // TODO: only make the lines on multiples of edoLabelStep; not multiples plus minEdo
		let y = marginY + (edo - minEdo)*edoStepY;
		document.getElementById('chart').innerHTML +=
		'<line x1="' + marginX + '" y1="' + y + '" x2="' + (width - marginX) + '" y2="' + y + '" style="stroke: dimGray; stroke-width: 1;" />'
		+ '<text x="' + (marginX/2 - 16) + '" y="' + (y + 2) + '" font-size="12px" font-family="sans-serif" fill="lightGray">' + edo + 'edo</text>';
	}
	// add target line
	document.getElementById('chart').innerHTML += '<line x1="' + (marginX + (targetPitch - minPitch)*pitchStepX) + '" y1="0" x2="' + (marginX + (targetPitch - minPitch)*pitchStepX) + '" y2="' + height + '" style="stroke: hsla(' + accentHue + ', 60%, 65%, 60%); stroke-width: 2;" />';
	
	// add data
	for (let edo = minEdo; edo <= maxEdo; edo++) { // TODO: add second best approximations in a different color; make them faint if outside the specified range
		let approxStep = Math.round(pitchUnitsToOctaves(pitchUnit, targetPitch) * edo); // TODO: make this work with non-octave equal temperaments
		let approxPitch = octavesToPitchUnits(pitchUnit, approxStep/edo);
		let x = marginX + (approxPitch - minPitch)*pitchStepX;
		let y = marginY + (edo - minEdo)*edoStepY;
		document.getElementById('chart').innerHTML +=
		'<line x1="' + x + '" y1="' + (y - lineRadius) + '" x2="' + x + '" y2="' + (y + lineRadius) + '" style="stroke: hsla(' + accentHue + ', 100%, 75%, 80%); stroke-width: 2;" />'
		+ '<text x="' + (x + 6) + '" y="' + (y - 1) + '" font-size="12px" fill="lightGray">' + approxStep + '\\' + edo + '<tspan x="' + (x + 6) + '" y="' + (y + 11) + '" font-size="9px">' + (approxPitch - targetPitch >= 0 ? '+' : '') + pitchUnitText(pitchUnit, approxPitch - targetPitch) + '</tspan></text>';
	}
	return 'Approximated ' + pitchUnitText(pitchUnit, targetPitch) + '.';
}

function drawEdoPrimeChart(minEdo, maxEdo, primeX, primeY, primeR, primeG, primeB) {
	if (arguments.length != 7) throw 'Internal Error: Wrong number of arguments.';
	
	const width = window.innerWidth - 40;
	const height = window.innerHeight - 40;
	
	document.body.innerHTML = '<svg id="chart" style="width: ' + width + 'px; height: ' + height + 'px;">Your browser does not support inline SVG.</svg>';
	
	// add data
	for (let edo = minEdo; edo <= maxEdo; edo++) { // TODO: add second best approximations in a different color; make them faint if outside the specified range
		let x = width * (1 - relativeError(primeX, edo));
		let y = height * relativeError(primeY, edo);
		document.getElementById('chart').innerHTML += '<circle cx="' + x + '" cy="' + y + '" r="6" stroke="lightGray" fill="rgb(' + (255 * (1 - relativeError(primeR, edo))) + ', ' + (255 * (1 - relativeError(primeG, edo))) + ', ' + (255 * (1 - relativeError(primeB, edo))) + ')" />' + '<text x="' + (x - 6) + '" y="' + (y - 10) + '" font-size="12px" font-family="sans-serif" fill="lightGray">' + edo + '</text>';
	}
	return 'Drawn Chart for x: ' + primeX + ', y: ' + primeY + ', r: ' + primeR + ', g: ' + primeG + ', b: ' + primeB + '.';
}

function jiApprox(pitchUnit, target, minDenom, maxDenom) {
	return 0; // TODO Approximates an interval with JI
}

function chordApprox(pitchUnit, overtoneStep, maxError, integerLimit, inputPitch1, inputPitch2, inputPitch3) { // TODO: count errors for intervals with notes other than the root
	if (arguments.length != 7) throw 'Internal Error: Wrong number of arguments.';
	document.body.innerHTML = '<table id="outputTable"></table>';
	document.getElementById('outputTable').innerHTML = '<tr><td class="tableHeader">#</td><td class="tableHeader">Ratio</td><td class="doubleBorder tableHeader">Pitch 1</td><td class="tableHeader">Error 1</td><td class="tableHeader">Pitch 2</td><td class="tableHeader">Error 2</td><td class="tableHeader">Pitch 3</td><td class="tableHeader">Error 3</td></tr>';
	let ratioCount = 0;
	for (let d = 1; d <= integerLimit; d += overtoneStep) {
		// find n1 (it should be possible to solve this without looping through every number)
		for (let n1 = 1; n1 <= integerLimit; n1 += overtoneStep) { // we start at one here rather than d to allow for negative cent values and so overtoneStep works properly
			let ratioPitch1 = octavesToPitchUnits(pitchUnit, Math.log2(n1/d));
			if (Math.abs(inputPitch1 - ratioPitch1) <= maxError) {
				// find n2
				for (let n2 = 1; n2 <= integerLimit; n2 += overtoneStep) {
					let ratioPitch2 = octavesToPitchUnits(pitchUnit, Math.log2(n2/d));
					if (Math.abs(inputPitch2 - ratioPitch2) <= maxError) {
						// find n3
						for (let n3 = 1; n3 <= integerLimit; n3 += overtoneStep) {
							let ratioPitch3 = octavesToPitchUnits(pitchUnit, Math.log2(n3/d));
							if (Math.abs(inputPitch3 - ratioPitch3) <= maxError) {
								// if successful, output to table
								if (coprime(new Array(d, n1, n2, n3))) document.getElementById('outputTable').innerHTML +=
								'<tr><td class="columnColor">' + ++ratioCount + '</td><td>'
								+ d + ':' + n1 + ':' + n2 + ':' + n3 + '</td><td class="columnColor doubleBorder">'
								+ pitchUnitText(pitchUnit, ratioPitch1) + '</td><td>'
								+ pitchUnitText(pitchUnit, inputPitch1 - ratioPitch1) + '</td><td class="columnColor">'
								+ pitchUnitText(pitchUnit, ratioPitch2) + '</td><td>'
								+ pitchUnitText(pitchUnit, inputPitch2 - ratioPitch2) + '</td><td class="columnColor">'
								+ pitchUnitText(pitchUnit, ratioPitch3) + '</td><td>'
								+ pitchUnitText(pitchUnit, inputPitch3 - ratioPitch3) + '</td></tr>';
							}
						}
					}
				}
			}
		}
	}
	return 'Approximated ' + pitchUnitText(pitchUnit, inputPitch1) + ', ' + pitchUnitText(pitchUnit, inputPitch2) + ', ' + pitchUnitText(pitchUnit, inputPitch3) + '. ' + ratioCount + ' ratios found with max error ' + pitchUnitText(pitchUnit, maxError) + '.';
}

function subgroup(x, y, maxH, maxErrorSteps) {
	if (arguments.length != 4) throw 'Internal Error: Wrong number of arguments.';
	let hArr = [];
	for (let h = 2; h <= maxH; h++) { // check the approximations of each harmonic
		let approxSteps = x * Math.log(h) / Math.log(y);
		if (Math.abs(Math.round(approxSteps) - approxSteps) <= maxErrorSteps) { // if the approximation is good enough, go through every entry in hArr and only add h to the array if it can't be produced by a combination of the other subgroup harmonics
			let hTemp = h; // this will get divided by the factorization algorithm
			for (let i = hArr.length - 1; i >= 0; i--) { // go from right to left to prioritize larger composite numbers in case dividing by a small prime leads to a dead end
				if (hTemp % hArr[i]  == 0) {
					hTemp /= hArr[i];
					i = hArr.length; // not hArr.length - 1 because the loop subtracts one at the end
				}
			}
			if (hTemp > 1) hArr.push(h); // once it makes it to the end, check whether h has been represented by harmonics already present, that it, it has not been reduced to one
		}
	}
	hArr.sort(function(a, b) {return smallestPrimeFactor(a) - smallestPrimeFactor(b);}); // TODO: instead sort composite harmonics by the smallest prime harmonic that is not part of the subgroup; make a table of smallest prime factors to make sorting more efficient; table takes up almost double the space of plain text
	// print hArr
	let subgroup = hArr[0];
	for (let i = 1; i < hArr.length; i++) subgroup += '.' + hArr[i];
	return subgroup;
}

function subgroupTable(minX, maxX, xStep, y, maxH, maxErrorSteps) { // TODO: make this work with any array of pitches so to work with unequal temperaments; make this work with non-integer y; deal with approximations like 11/7 without 11 or 7 as the errors cancel out; this is generally messy in the more heavily nested sections; sort the output by prime factorization, show consistent harmonics
	if (arguments.length != 6) throw 'Internal Error: Wrong number of arguments.';
	document.body.innerHTML = '<table id="outputTable"><tr><td class="tableHeader">' + (y == 2 ? 'Edo' : 'ED' + y) + '</td><td class="tableHeader">Subgroup</td></tr></table>';
	for (let x = minX; x <= maxX; x += xStep) document.getElementById('outputTable').innerHTML += '<tr><td>' + (x.toPrecision(13)/1) + '</td><td>' + subgroup(x, y, maxH, maxErrorSteps) + '</td></tr>'; // 13 is the maximum precision that can always be displayed without rounding errors, and then we divide by 1 to remove the trailing zeros
	return 'Listed ' + maxErrorSteps + '-step subgroups for ' + minX + (y == 2 ? 'edo' : 'ed' + y) + ' to ' + maxX + (y == 2 ? 'edo' : 'ed' + y) + '.';
}

function isInSubgroup(ratio, subgroup) {
	if (arguments.length != 2) throw 'Internal Error: Wrong number of arguments.';
	for (let i = 0; i < ratio.length; i++) {
		for (let j = 0; j < subgroup.length; j++) {
			while (ratio[i] % subgroup[j] == 0) ratio[i] /= subgroup[j];
		}
		if (ratio[i] > 1) return false;
	}
	return true;
}

function nameJI(pitchUnit, integerLimit, subgroup, bound) {
	if (arguments.length != 4) throw 'Internal Error: Wrong number of arguments.';
	document.body.innerHTML = '<table id="outputTable"><tr><td class="tableHeader">#</td><td class="tableHeader">Ratio</td><td class="tableHeader">Size</td></tr></table>';
	let count = 0;
	for (let d = 1; d <= integerLimit; d++) {
		for (let n = d + 1; n <= integerLimit; n++) {
			if (n/d < bound && coprime(new Array(d, n)) && isInSubgroup(new Array(d, n), subgroup)) {
				document.getElementById('outputTable').innerHTML += '<tr><td>' + ++count + '</td><td>' + n + '/' + d + '</td><td>' + pitchUnitText(pitchUnit, octavesToPitchUnits(pitchUnit, Math.log2(n/d))) + '</td></tr>';
			}
		}
	}
	return 'Found ' + count + ' ratios less than ' + bound + '.';
}


// PROGRESSIVE APPROXIMATION STUFF

function progApprox(r, maxEdo) {
	const rOct = Math.log2(r[1] / r[0]);
	let maxErrOct = 1; // will be overwritten immediately
	for (let edo = 1; edo <= maxEdo; edo++) {
		let errOct = (Math.round(rOct * edo) / edo) - rOct;
		if (Math.abs(errOct) < maxErrOct) {
			maxErrOct = Math.abs(errOct);
			console.log(Math.round(rOct * edo) + '\\' + edo + ' = ' + (1200 * errOct) + 'c');
		}
	}
}

function alternatingRank2(gen1, gen2, period, countUp, countDown) {
	let scale = [];
	for (let i = -countDown; i <= countUp; i++) scale.push((gen1*Math.ceil(i/2) + gen2*Math.floor(i/2)).mod(period));
	return scale.sort((a, b) => a - b);
}

function offsetRank2(gen, offset, period, countUp, countDown) {
	return alternatingRank2(offset, gen - offset, period, countUp, countDown);
}



// CONTINUED FRACTION STUFF

function continuedFractionRationality(tuple) {
	let sum = 0;
	if (tuple[tuple.length - 1] == 1 && tuple.length > 1) tuple[tuple.length - 2] += tuple.pop(); // tuple.pop() always returns 1 in this case but it accomplishes this in only one line
	for (let i = 0; i < tuple.length; i++) sum += Math.pow(tuple[i], -i); // should the power be -i or -1 - i? What do I do about 1+1/(1+1) and 1+1/(2) having different scores?
	return 1/sum;
}

/*
TODO: return step sizes


Blackdye
offsetRank2(702, 520, 1200, 4, 5)
(10) [0, 22, 204, 316, 498, 520, 702, 814, 996, 1018]
offsetRank2(498, 316, 1200, 4, 5)
(10) [0, 22, 204, 316, 498, 520, 702, 814, 996, 1018]
alternatingRank2(1200*Math.log2(6/5), 1200*Math.log2(10/9), 1200, 4, 5)
(10) [0, 21.506289596714623, 203.91000173077475, 315.64128700055244, 498.0449991346127, 519.5512887313273, 701.9550008653873, 813.6862861351651, 996.0899982692254, 1017.59628786594]
alternatingRank2(1200*Math.log2(27/20), 1200*Math.log2(10/9), 1200, 4, 5)
(10) [0, 21.506289596715078, 203.9100017307751, 315.6412870005523, 498.04499913461245, 519.5512887313275, 701.9550008653875, 813.6862861351647, 996.0899982692249, 1017.59628786594]

Diasem
offsetRank2(498, 266, 1200, 4, 4)
(9) [0, 204, 266, 470, 498, 702, 764, 968, 996]
*/



// UNFINISHED FUNCTIONS

function rank3Table(r0, r1, r2, range1, range2) {
	if (arguments.length != 5) throw 'Internal Error: Wrong number of arguments.';
	let m0 = rToM(r0); // converting everything to monzos has massive performance increases when repeatedly stacking complex ratios; we make these variables so it doesn't have to recalculate every time the loop repeats
	let m1 = rToM(r1);
	let m2 = rToM(r2);
	let row = '<tr class="tableHeader"><td></td>';
	for (let j = -range2; j <= range2; j++) row += '<td>' + j + '</td>';
	document.body.innerHTML = '<table id="outputTable">' + row + '</tr></table>';
	for (let i = -range1; i <= range1; i++) {
		let row = '<tr><td class="tableHeader">' + i + '</td>';
		for (let j = -range2; j <= range2; j++) {
			let unreducedM = stackM([m1, m2], [i, j]);
			let reducedR = mToR(stackM([m0, unreducedM], [-Math.floor(logBase(rToQ(mToR(unreducedM)), rToQ([1,2]))), 1]));
			row += '<td>' +  reducedR[1] + '/' + reducedR[0] + '</td>'
		}
		document.getElementById('outputTable').innerHTML += row + '</tr>';
	}
}

function nameNotes(generatorSteps, periodSteps, generatorNoteLetters) {
	let noteArray = [];
	let limit = Math.ceil(periodSteps / 2); // if generatorNoteLetters has odd length?
	for (let i = -limit; i < limit; i++) { // generators up or down
		if (scale[i] != '') break; // hit the point where it repeats
		
	}
}

// TODO finish the table creation
function scaleCreator(scaleSize, maxIntervalSteps) {
	document.body.innerHTML = '<table id="outputTable" class="equalTable"></table>';
	let html = '';
	let tableRows = 2 * (scaleSize + maxIntervalSteps);
	for (let row = 0; row < tableRows; row++) {
		if (row <= scaleSize * 2) {
			if (row % 2 == 0) html += '<tr><td rowspan="2"><input type="text" /></td>' + '<td rowspan="2">h</td>'.repeat(Math.min(row, maxIntervalSteps) / 2) + '</tr>';
			else html += '<tr>' + '<td rowspan="2">h</td>'.repeat((Math.min(row, maxIntervalSteps) + 1) / 2) + '</tr>';
		}
	}
	document.getElementById('outputTable').innerHTML = html;
}

// TODO make this work, like, at all
// target and period are arrays
function calculateGeneratorDefinition(target, generators, period, periodExponent) {
	if (generators == 0) return;
	if (generators > 0) {
		target[0] *= generators;
		target[1] *= generators;
	} else {
		let temp = target[0];
		target[0] = target[1] * -generators;
		target[1] = temp * -generators;
	}
	// reduce by period
	target = reduce(target);
	// (generators*targetN/targetD)^1/4
}

function consistentToDistance(x, y, h1, h2) {
	if (arguments.length != 4) throw 'Internal Error: Wrong number of arguments.';
	if (h1 == h2) return Infinity;
	let lnBase = Math.log(y);
	let steps1 = x * Math.log(h1) / lnBase; // log change of base equation
	let steps2 = x * Math.log(h2) / lnBase;
	for (let d = 1; true; d++) {
		if (Math.round(steps2)*d - Math.round(steps1)*d != Math.round((steps2 - steps1) * d)) return d - 1;
	}
}

function consistentOddLimit(a) { // TODO: doesn't give correct results https://en.xen.wiki/w/Minimal_consistent_EDOs
	for (let h = 3; true; h += 2) {
		if (consistentToDistance(a, 2, 2, h) <= 1) return h - 2;
	}
}

function jiInsertion(rArray, insertionType, placeAtEnd, iterations) { // ex. 5/4, 3/2, 2/1
	if (arguments.length != 4) throw 'Internal Error: Wrong number of arguments.';
	if (rArray.length < 1) throw 'Internal Error: rArray cannot be empty.';
	if (insertionType < 0 || insertionType > 2) throw 'Internal Error: Invalid insertion type.';
	let mArray = [];
	for (let i = 0; i < rArray.length; i++) {
		if (rToQ(rArray[i]) <= 1) throw 'Internal Error: Ratio must be > 1.';
		mArray.push(rToM(rArray[i]));
	}
	let steps0 = [mArray[0]];
	for (let i = 1; i < rArray.length; i++) steps0.push(stackM([mArray[i], mArray[i - 1]], [1, -1]));
	document.body.innerHTML = 'Iteration 0: ' + outputStepsLine(steps0);
	
	for (let i = 1; i <= iterations; i++) {
		let stepsQ0 = [];
		for (let i = 0; i < steps0.length; i++) {
			stepsQ0.push(rToQ(mToR(steps0[i])));
		}
		
		let sortedSteps = [];
		for (let j = 0; j < steps0.length; j++) {
			let unique = true;
			for (let k = 0; k < j; k++) {
				if (stepsQ0[k] == stepsQ0[j]) {
					unique = false;
					break;
				}
			}
			if (unique) sortedSteps.push([steps0[j], stepsQ0[j]]);
		}
		sortedSteps.sort(function(a, b){return a[1] - b[1]});
		
		let stepToInsert = sortedSteps[(insertionType == 1 ? sortedSteps.length - 2 : 0)][0];
		let steps1 = [];
		for (let j = 0; j < steps0.length; j++) {
			if (stepsQ0[j] == sortedSteps[sortedSteps.length - 1][1] || (insertionType == 2 && stepsQ0[j] > sortedSteps[0][1])) {
				if (placeAtEnd) {
					steps1.push(stackM([steps0[j], stepToInsert], [1, -1]));
					steps1.push(stepToInsert);
				} else {
					steps1.push(stepToInsert);
					steps1.push(stackM([steps0[j], stepToInsert], [1, -1]));
				}
			}
			else steps1.push(steps0[j]);
		}
		document.body.innerHTML += 'Iteration ' + i + ': ' + outputStepsLine(steps1);
		steps0 = steps1;
	}
}

function outputStepsLine(steps) {
	let html = '';
	for (let j = 0; j < steps.length - 1; j++) {
		html += rToSlash(mToR(steps[j])) + ', ';
	}
	html += rToSlash(mToR(steps[steps.length - 1])) + '<br>';
	return html;
}

let structure = [2, 1, 2, 0, 2, 1, 2, 0, 2];
//let structure = [0, 2, 1, 2, 0, 2, 1, 2, 0, 2];
let composition = [-2, 2, -1, 2]; // generators down and up, for plain and offset chains
//let composition = [-2, 2, -2, 2];
function isValidGO(gen, offset) { // this doesn't account for possible occurences of the same structure with a completely different generator and offset
	let scale = [];
	for (let g = composition[0]; g <= composition[1]; g++) if (g != 0) scale.push((g * gen).mod(1200));
	for (let g = composition[2]; g <= composition[3]; g++) scale.push((g * gen + offset).mod(1200));
	scale.push(1200);
	scale.sort(function(a, b){return a - b});
	for (let i = scale.length - 1; i > 0; i--) scale[i] -= scale[i - 1];
	let uniqueSteps = [scale[0]];
	for (let i = 1; i < scale.length; i++) if (!uniqueSteps.includes(scale[i])) uniqueSteps.push(scale[i]);
	uniqueSteps.sort(function(a, b){return a - b});
	for (let i = 0; i < scale.length; i++) {
		if (structure[i] != uniqueSteps.indexOf(scale[i])) return false;
	}
	return true; // 37/32 * 3/2 111/64*32/55 111/110, 111/64*4/7 112/111
}
function findValidGO(minGen, maxGen, genStep, minOffset, maxOffset, offsetStep) {
	document.body.style.fontFamily = 'monospace';
	document.body.innerHTML = '----';
	for (let o = minOffset; o <= maxOffset; o += offsetStep*2) document.body.innerHTML += (o.toString()[0] || '-') + ' '; document.body.innerHTML += '<br>----';
	for (let o = minOffset; o <= maxOffset; o += offsetStep*2) document.body.innerHTML += (o.toString()[1] || '-') + ' '; document.body.innerHTML += '<br>----';
	for (let o = minOffset; o <= maxOffset; o += offsetStep*2) document.body.innerHTML += (o.toString()[2] || '-') + ' '; document.body.innerHTML += '<br>----';
	for (let o = minOffset; o <= maxOffset; o += offsetStep*2) document.body.innerHTML += (o.toString()[3] || '-') + ' '; document.body.innerHTML += '<br>';
	for (let g = minGen; g <= maxGen; g += genStep) {
		document.body.innerHTML += g + ' ';
		for (let o = minOffset; o <= maxOffset; o += offsetStep) {
			document.body.innerHTML += (isValidGO(g, o) ? '#' : '.');
		}
		document.body.innerHTML += '<br>';
	}
}

function aberrismicSvgPattern(scales, lineStyle, repetitions, margin, eqIntervalWidth, rowHeight, transitionHeight, closeTriangles) {
    if (arguments.length != 8) throw 'Internal Error: Wrong number of arguments.';
	
	// simultaneously find the central scale and check for errors in the arguments
	let centralIndex = -1;
	for (let i = 0; i < scales.length; i++) {
		if (scales[i].length == 4) { // central scale found
			if (centralIndex < 0) centralIndex = i;
			else throw 'Internal Error: Only one central scale is allowed; step analogue array must be absent exactly once.';
		}
		else if (scales[i].length != 5) throw 'Internal Error: Scale array format should be [Lms string, L ratio, m ratio, s ratio, step analogue array for last scale going outward from the center].';
		for (let j = 1; j < scales[i].length; j++) {
			if (scales[i][j][0] > scales[i][j][1]) throw 'Internal Error: Ratio format should be [d,n], where d <= n.';
		}
	}
	if (centralIndex < 0) throw 'Internal Error: A central scale must be defined by omitting the step analogue array exactly once.';
	
	//Food service workers in the furry world have to wear a furnet around their whole upper body if they have fur over a certain length. Australian shepherds have to trim to under an inch. They also have to trim hand fur so short that it can't reasonably fall out into the food.
	
	let lines = [[]]; // [ each line: [ points on the line, index = scale#: [d, n, step of corresponding scale] ] ]; first array is the unison line, used in approximations later
	for (let i = 0; i < scales.length; i++) lines[0].push([1,1, 0]); // for loops are used to populate the array because .fill() creates an array full of references
	let currentR = [1,1]; // current ratio of current scale
	for (let i = 0; i < scales[centralIndex][0].length; i++) { // populate the list with the notes from the smallest scale; branches will be added to the end
		currentR = stack(currentR, scales[centralIndex][lmsToInt(scales[centralIndex][0].charAt(i)) + 1]);
		lines.push([]);
		for (let j = 0; j < scales.length; j++) lines[lines.length - 1].push([]);
		lines[lines.length - 1][centralIndex] = [currentR[0], curentR[1], i + 1];
	}
	goodLog3d(lines);
	for (let i = centralIndex - 1; i >= 0; i--) { // draw lines going down the scale list
		currentR = [1,1];
		stepLoopDown:
		for (let j = 0; j < scales[i][0].length; j++) { // for each step of the current scale in the list
			currentR = stack(currentR, scales[i][lmsToInt(scales[i][0].charAt(j)) + 1]);
			for (let k = 0; k < lines.length; k++) { // find the index of the line containing the last scale's note that's the step analogue for currentR
				if (lines[k][i + 1][2] == scales[i][4][j]) { // line found
					if (lines[k][i].length > 0) { // if this scale already has a point on this line, create a new line
						lines.push([]);
						for (let l = 0; l < scales.length; l++) lines[lines.length - 1].push([]);
						lines[lines.length - 1][i] = [currentR[0], curentR[1], j]
						lines[lines.length - 1][i + 1] = lines[k][i + 1].slice(); // copy ratio from last scale to start new line
					} else lines[k][2] = [currentR[0], curentR[1], j]; // if this scale doen't yet have a point on this line add it
				}
			}
		}
	}
	goodLog3d(lines);
	for (let i = centralIndex + 1; i < scales.length; i++) { // draw lines going up the scale list
		currentR = [1,1];
		stepLoopUp:
		{}
	}
	
	/* a vestige of a time when I thought I'd be using a different line-drawing
	let rList = []; // where each interval occurs: [[[d,n], [scale, scale, ...]], [[d,n], [scale, scale, ...]], ...]
	for (let i = 0; i < scales.length; i++) { // go through each scale, adding new ratios to rList as needed
		let currentR = [1,1]; // current ratio of current scale
		stepLoop:
		for (let j = 0; j < scales[i][0].length; j++) { // for each step in the current scale
			currentR = stack(currentR, scales[i][lmsToInt(scales[i][0].charAt(j)) + 1]);
			for (let k = 0; k < rList.length; k++) { // search every ratio in rList for currentR
				if ((rList[k][0][0] == currentR[0]) && (rList[k][0][1] == currentR[1])) { // ratio found, update rList
					rList[k][1].push(i); // add current scale to list of scales that use this interval
					continue stepLoop; // stop searching and continue to the next step in the scale
				}
			}
			// ratio was not found, add a new one
			for (let k = 0; k < rList.length; k++) { // search every ratio in rList for one that's larger than currentR
				if ((rList[k][0][1] / rList[k][0][0]) > (currentR[1] / currentR[0])) { // ratio found, insert currentR before it
					rList.splice(k, 0, [currentR.slice(), [i]]); // add .slice() to convert currentR reference to value, or rList will change each iteration
					continue stepLoop; // ratio is already added, continue to the next step in the scale
				}
			}
			rList.push([currentR.slice(), [i]]); // currentR is larger than any ratio in rList, so put at it the end
		}
	}
	goodLog3d(rList);
	
	
	// rList is populated, now draw the diagram
	let html = '<svg width="' + (margin*2 + eqIntervalWidth*repetitions) + '" height="' + (margin*2 + rowHeight*scales.length) + '">\n'; // draw first unison line
	for (let i = 0; i < repetitions; i++) {
		for (let j = 0; j < rList.length; j++) { // draw a line or separate lines for each interval
			rList[j][1].sort(); // the scales that use each ratio have to be sorted so each line can be drawn contiguously where applicable
			let lineStartingScale = rList[j][1][0];
			for (let k = 1; k < rList[j][1].length; k++) {
				if (rList[j][1][k] != lineStartingScale + 1) { // line ends here, draw it and move on
				html +=
						'<line x1="' + (margin + eqIntervalWidth*i) +
						'" y1="' + margin +
						'" x2="' + (margin + eqIntervalWidth*i) +
						'" y2="' + (margin + rowHeight*scales.length) +
						'" style="' + lineStyle + '" />\n'; // add tonic line
					// TODO add rest of lines

					// TODO draw line and ratio label on top or bottom
					lineStartingScale = rList[j][1][k]; // reset to start the next line
				}
			}
			// TODO draw final line
		}
	}
	document.body.innerHTML = html +
		'<line x1="' + (margin + eqIntervalWidth*repetitions) +
		'" y1="' + margin +
		'" x2="' + (margin + eqIntervalWidth*repetitions) +
		'" y2="' + (margin + rowHeight*scales.length) +
		'" style="' + lineStyle + '" />\n</svg>'; // add line for final octave and print */
}

function assignToVal(pitchUnit, edx, equave, subgroup) {
// subgroup = [[[d,n], positive wart integer, maximum exponent], ...] not including equave
	let mappings = []; // how each prime is mapped in the val
	let currentExps = []; // the current exponent applied to each prime
	for (let i = 0; i < subgroup.length; i++) {
		let edxApprox = edx * logBase(rToQ(subgroup[i][0]), rToQ(equave));
		if (edxApprox % 1 < 0.5) { // best approximation rounds down; even warts tend down and odd warts tend up
			mappings.push(subgroup[i][1] % 2 == 0 ? Math.floor(edxApprox) - subgroup[i][1]/2 : Math.ceil(edxApprox) + (subgroup[i][1]-1)/2);
		} else { // best approximation rounds up; even warts tend up and odd warts tend down
			mappings.push(subgroup[i][1] % 2 == 0 ? Math.ceil(edxApprox) + subgroup[i][1]/2 : Math.floor(edxApprox) - (subgroup[i][1]-1)/2);
		}
		currentExps.push(-subgroup[i][2]);
	}
	let list = []; // [[[d,n], [d,n], ... ], ...], the ratios within the given parameters mapped to each step (index) of the equave
	for (let i = 0; i < edx; i++) list.push([]); // populate array with arrays to push ratios into
	listLoop:
	for (let i = 0; true; i++) { // position of the current digit/exponent to increment; break condition is near the bottom of this block
		for (currentExps[i] = -subgroup[i][2]; currentExps[i] <= subgroup[i][2]; currentExps[i]++) { // for every possible value of the current digit/exponent from -max to max
			let currentR = [1,1];
			let currentETStep = 0;
			for (let j = 0; j < subgroup.length; j++) { // calculate currentR by going through each prime
				if (currentExps[j] < 0) { // add the prime to a certain power to the ratio while keeping it as integers
					currentR[0] *= Math.pow(subgroup[j][0][1], -currentExps[j]);
					currentR[1] *= Math.pow(subgroup[j][0][0], -currentExps[j]);
				} else {
					currentR[0] *= Math.pow(subgroup[j][0][0], currentExps[j]);
					currentR[1] *= Math.pow(subgroup[j][0][1], currentExps[j]);
				}
				currentETStep += mappings[j]*currentExps[j]; // only takes one line of code to do the same in logarithmic pitch space
			}
			// equave-reduce
			while (rToQ(currentR) >= rToQ(equave)) { // TODO: not the most elegant solution, but short
				currentR[0] *= equave[1];
				currentR[1] *= equave[0];
			}
			while (rToQ(currentR) < 1) {
				currentR[0] *= equave[0];
				currentR[1] *= equave[1];
			}
console.log(...currentExps);
			list[currentETStep.mod(edx)].push(reduce(currentR));
		}
		// reset this digit and previous in currentExp, and increment the next one
		// TODO: not the most elegant solution once again
		let freeIndex = 0;
		freeIndexCheck: {
			for (freeIndex = i; freeIndex < subgroup.length; freeIndex++) { // look for the next suitable digit to increment
				if (currentExps[freeIndex] < subgroup[freeIndex][2]) break freeIndexCheck; // found a digit that can be incremented with no consequence, usually at freeIndex = i
			}
			break listLoop; // if no next digit to increment, all ratios have been checked
		}
		currentExps[freeIndex]++; // increment digit
		for (let j = 0; j < freeIndex; j++) { // reset previous digits
			currentExps[j] = -subgroup[j][2];
		}
		i = 0; // start back at the first digit
	}
	list.push([equave.slice()]); // add the equave as the last interval
	for (let i = 0; i < list.length; i++) { // display list
		let text = i + '\\' + edx + ' ' + pitchUnitText(pitchUnit, octavesToPitchUnits(pitchUnit, rToO(equave)*i/edx)) + ':';
		for (let j = 0; j < list[i].length; j++) text += ' ' + rToSlash(list[i][j]);
		console.log(text);
	}
}

</script>
</head>
<body>
Open the console to execute JavaScript commands. You may need to update your browser if it gives an error over an unrecognized function.
<br>
<br>Argument Abbreviations:
<br>x, y: xEDy (e.g. 12ed2)
<br>h: harmonic
<br>
<br>
<br>TODO: command list
<br>
<br>jiInsertion(rArray, insertionType, placeAtEnd, iterations)
<br>Example: jiInsertion([[4,5], [2,3], [8,15], [1,2]], 0, false, 3);
<br>
<br>insertionType:
<br>0: sL (insert smallest step)
<br>1: mL (insert second largest step)
<br>2: sML (insert smallest step into all other steps)
</body>
<script>
/* aberrismicSvgPattern([
	['sLmLsLsLmLs', [8,9], [48,49], [63,64], [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9]],
	['LmLsLmLsL', [8,9], [27,28], [63,64], [1, 2, 3, 3, 4, 5, 6, 6, 7]],
	['LmLLmLL', [8,9], [243,256], [1,1]],
	['sLmLsLmLsL', [9,10], [15,16], [80,81], [0, 1, 2, 3, 3, 4, 5, 6, 6, 7]],
	['LmLsLLmL', [9,10], [25,27], [80,81], [1, 2, 3, 3, 4, 5, 6, 7]]
], 'stroke:red; stroke-width:4;',
5, 10, 200, 20, 5, true); */
assignToVal('c', 27, [1,2], [[[1,3], 0, 2], [[1,5], 0, 2]]);
</script>
</html>
